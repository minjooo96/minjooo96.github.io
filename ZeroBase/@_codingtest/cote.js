/*
[문제 설명]
숫자로 이루어진 문자열 s가 있습니다. 이 문자열에서 가장 많이 등장하는 수를 출력하는 함수, solution을 완성해주세요.

예를 들어, s가 '104001100'로 주어질 때, 가장 많이 등장하는 수는 0입니다.

[제한 사항]

등장하는 수가 같은 경우, 작은 수를 출력합니다.
[입력 형식]

s는 길이가 1 이상 100 이하의 문자열입니다.
s는 숫자로 구성됩니다.
[출력 형식]

가장 많이 등장하는 수를 출력합니다.
*/

function solution(s) {
    s = String(s);
    let arr = new Array();
    arr = s.split('');
    
    for(let i = 0; i < arr.length; i++){ arr[i] = Number(arr[i]); }
    arr.sort();

    let saveArr = new Array();
    for(let i = 0; i < 10; i++){ saveArr[i] = 0; }
    
    let bvalue = new Number();
    let saveNum = 1;
    arr.forEach(element => {
        if( bvalue !== element ){ saveNum = 1; }
        for (let i = 0; i < 10; i++) {
            if( element == i ){
                saveArr[i] = saveNum++;
                bvalue = element;
            }
        }
    });

    let max = 0;
    max = Math.max.apply(null, saveArr);

    let resultArr = [];
    for (let i = 0; i < saveArr.length; i++) {
        if( saveArr[i] == max ){ resultArr.push(i); }
    }
    let result = Math.min.apply(null, resultArr);
    return result;
}

// [문제 설명]
// 온라인으로 주문을 받고 있습니다. 주문 번호는 주문 순서대로 1부터 증가합니다.
// 일부 주문이 취소된 주문 내역이 주어질 경우, n번째 주문 취소된 주문 번호를 구하는 함수, solution을 완성해주세요.

// 예를 들어, 주문 내역 orders [2, 4, 5, 7]이 있고, 3번째 취소된 주문 번호는 6입니다.

// 1번째 취소 주문 번호는 1
// 2번째 취소 주문 번호는 3
// 3번째 취소 주문 번호는 6

// [입력 형식]

// orders는 길이가 1 이상 1,000 이하인 배열입니다.
// 주문 번호는 최대 1,000건까지 존재합니다.
// n은 1 이상 1,000 이하의 정수입니다.
// [출력 형식]

// n번째 취소된 주문 번호를 int 형식으로 구합니다.

// function solution(orders, n) {
//     let orderArr = orders;
//     let max = Math.max.apply(null, orderArr);
//     if( 1 > n && n > 1000 ) return;
//     if( 1 > orderArr.length && orderArr.length > 1000 ) return;
//     if( max < n ) return;
//     let cancleArr = [];
//     for (let i = 1; i <= max; i++) {
//         if( !orderArr.includes(i) ){
//             cancleArr.push(i);
//         }
//     }
//     return cancleArr[n-1];
// }
// solution([5, 100, 500, 800, 200, 255], 300);
// console.log(solution([5, 100, 500, 123, 200, 255], 789));
// console.log( solution([5, 100, 500, 800], 799) );


/*


문제 설명
[문제 설명]
민규와 지수는 구슬 맞추기 게임을 하려고 합니다. 게임의 방식은 숫자가 적힌 구슬이 한 쌍씩 들어있는 주머니가 있고, 술래는 주머니에서 상대가 알지 못하게 하나의 구슬을 빼내거나, 빼내지 않습니다.

그런 후 상대는 술래가 주머니에서 구슬을 빼냈는지 빼내지 않았는지, 그리고 술래가 구슬을 빼냈다면 빼낸 구슬의 숫자를 맞추는 게임입니다.

주머니 안에 들어있는 구슬에 적힌 숫자 배열 arr가 주어질 때, 술래가 빼낸 구슬의 번호를 출력하는 함수, solution을 완성해주세요.

[제한 사항]

구슬에 적힌 숫자는 1 이상 100,000 이하의 정수입니다.
술래는 주머니에서 구슬을 한 개만 빼거나, 빼지 않을 수 있습니다.
[입력 형식]

술래의 차례가 지난 후, 주머니에 남은 구슬에 적힌 번호의 배열 arr가 주어집니다.
arr는 길이가 1 이상 10,000 이하의 배열입니다.
[출력 형식]

술래가 가져간 구슬의 번호를 int 형식으로 출력합니다.
술래가 구슬을 가져가지 않았다면, 0을 출력합니다.


*/
// function solution(arr) {

//     // arr
//     let result = 0;
//     let saveArr = new Array( Math.max.apply(null, arr) );
//     let saveLength = 0;
    
//     if( arr.length % 2 == 0 ){
//         result = 0;
//     }else{
//         for (let i = 0; i < arr.length; i++) {

//             // arr.slice(arr[i]).incldes(arr[i])

//             console.log( arr.slice(arr[i]) );
            
//         }
//     }
//     return result;
// }
// solution( [1, 1, 3, 3, 2] );






/*

.////

[문제 설명]
포화 이진 트리란, 리프 노드를 제외한 모든 노드가 2개의 자식 노드를 가지는 트리를 말합니다.
높이가 n인 포화 이진 트리의 노드 수를 구하려고 합니다.

예를 들어, 높이 n이 5인 포화 이진 트리의 노드 수는 31개입니다.

높이 n이 주어질 때, 트리의 모든 노드 개수를 출력하는 함수, solution을 완성해주세요.
결과값이 매우 클 수 있으니, 1,000,000,007로 나눈 나머지 값을 구해주세요.

[입력 형식]

n은 1 이상 1000000_000 이하의 정수입니다.
[출력 형식]

노드의 개수를 1,000,000,007로 나눈 나머지 값을 int 형식으로 출력합니다.
///////

문제 설명]
문자열에 연속한 2개의 같은 문자가 존재하지 않도록 만들고 싶습니다. 연속한 2개의 같은 문자가 존재한다면 이 문자를 지우고 남은 문자열을 이어 붙입니다. 이 과정을 연속한 2개의 같은 문자가 없을 때까지 반복하면 목표한 문자열을 얻게 됩니다.

문자열 s가 주어질 때, 위와 같은 과정을 적용해서 나오는 문자열을 출력하는 함수, solution을 완성해주세요.

[입력 형식]

s는 길이가 1 이상 100,000 이하의 문자열입니다.
s는 알파벳 소문자로만 이루어져 있습니다.
[출력 형식]

중복을 제거한 문자열을 출력합니다.

.///////////////


[문제 설명]
3 x 3개의 격자 형태의 두더지 게임판이 있습니다. 두더지들은 들어가거나 나와 있는데, 이 두더지들을 모두 나오도록 바꾸는 게임입니다.
두더지를 조작하는 유일한 방법은 10개의 스위치를 조작하는 것으로, 각 스위치는 1개 이상의 두더지에 연결되어 있습니다.
한 스위치를 누를 때마다, 해당 스위치와 연결된 나와 있던 두더지는 들어가고, 들어가 있던 두더지는 나옵니다.
이때, 모든 두더지를 나오게 하려면 최소한 스위치를 몇 번이나 눌러야 할지를 출력하는 함수, solution을 완성해주세요.

예를 들어, 게임판의 9마리 두더지 상태 state로 [ 1, 0, 1, 0, 0, 1, 1, 1, 1 ]가 있고, 10개의 스위치에 연결된 두더지 번호 linkNums가 [ [1], [7], [8], [4, 7], [1, 3], [3, 4, 8], [0], [6], [2], [1, 4] ] 라고 가정할 때,
스위치에 연결된 두더지 정보는 다음과 같습니다.

스위치 0에 연결된 두더지 번호 1
스위치 1에 연결된 두더지 번호 7
스위치 2에 연결된 두더지 번호 8
스위치 3에 연결된 두더지 번호 4, 7
스위치 4에 연결된 두더지 번호 1, 3
스위치 5에 연결된 두더지 번호 3, 4, 8
스위치 6에 연결된 두더지 번호 0
스위치 7에 연결된 두더지 번호 6
스위치 8에 연결된 두더지 번호 2
스위치 9에 연결된 두더지 번호 1, 4
이때, 모든 두더지를 나오게 하려면 최소한 3번의 스위치(스위치 0, 2, 5)를 눌러야 합니다.

[제한 사항]

두더지의 상태는 0이면 들어가 있는 두더지, 1이면 나와 있는 두더지입니다.
[입력 형식]

두더지 상태 state가 주어집니다.
state는 0과 1로 이루어진 길이가 9인 배열입니다.
스위치에 연결된 두더지 번호 linkNums가 주어집니다.
linkNums는 각 스위치에 연결된 두더지 번호로 이루어진 길이가 10인 배열입니다.
[출력 형식]

모든 두더지를 나오게 하도록 스위치를 눌러야 하는 최소한의 수를 int 형식으로 출력합니다.
모든 두더지를 나오게 할 수 없으면 -1을 출력합니다.


////////////////////////


[문제 설명]
2020 도쿄 올림픽에 많은 육상 주자들이 참가했습니다.
각 국가에서 국가 대표 예선전이 진행되었습니다.
선발된 육상 주자들의 번호가 IOC에 전달되고 이를 기준으로 선수선발을 하려고 합니다.
선수 번호를 순서대로 정렬한 뒤에 n번째 순서의 선수 번호를 출력하는 함수, solution을 완성해주세요.

[제한 사항]

각 배열에 포함된 번호들은 다른 배열의 번호들과 서로 중복될 수 있습니다.
각 국가의 총선수들은 100명 이내입니다.
각 국가 참가자들의 리스트는 오름차순으로 정렬되어 있습니다.
전체 참가 국가들의 선수들의 순서도 오름차순으로 되어있습니다.
전체 참가 국가와 각 국가의 선수들의 숫자는 같습니다. (m * m)
[입력 형식]

참가국별 참가 선수 번호 arr는 m * m 길이의 숫자 배열입니다.
n번째 순서를 나타내는 num은 1 이상 100 이하의 정수입니다.
[출력 형식]

n번째 순서의 선수 번호를 int 형식으로 출력합니다.

*/

// function solution(arr, Num) {
//     if( Num < 1 && Num > 100 ) return;
//     Num = Num-1;
//     let allArr = [];
//     for (let i = 0; i < arr.length; i++) {
//         for (let j = 0; j < arr[i].length; j++) {
//             allArr.push(arr[i][j]);
//         }
//     }
//     allArr = allArr.sort(function(a, b){ return a-b; });
//     return allArr[Num];
// }
// console.log(solution( [[1, 2, 22], [3, 4, 23], [8, 9, 33]], 7));

/*

////
9
[문제 설명]
정수 n이 주어집니다. 1부터 n까지의 정수를 각각 이진수로 나타내었을 때, 1이 등장하는 두 번째 최상위 비트 자리의 수를 모두 더하여 출력하시오.
예를 들어, 131을 이진수로 나타내면 10000011이고, 최상위 비트는 27인 128이며, 두 번째 최상위 비트는 21인 2입니다.
만약 4와 같이 이진수로 나타내었을 때 1이 단 한 번만 나타나는 수의 경우에는 0을 더합니다.

만약 n이 6으로 주어진다고 가정할 때, 두 번째 최상위 비트의 자릿수를 모두 더한 결과는 다음과 같습니다.

숫자 1의 비트 1에서 두 번째 최상위 비트는 없으므로 0입니다.
숫자 2의 비트 10에서 두 번째 최상위 비트는 없으므로 0입니다.
숫자 3의 비트 11에서 두 번째 최상위 비트의 수는 20이므로 1입니다.
숫자 4의 비트 100에서 두 번째 최상위 비트는 없으므로 0입니다.
숫자 5의 비트 101에서 두 번째 최상위 비트의 수는 20이므로 1입니다.
숫자 6의 비트 110에서 두 번째 최상위 비트의 수는 21이므로 2입니다.
결과 : 4

[제한 사항]

두 번째 최상위 비트가 없으면 0을 더합니다.
[입력 형식]

n은 1 이상 10,000 이하의 정수입니다.
[출력 형식]

1부터 n까지의 정수를 각각 이진수로 나타내었을 때, 1이 등장하는 두 번째 최상위 비트 자리의 수를 더하여 int 형식으로 출력하세요.
///


10
[문제 설명]
병원에서 진료를 위해 예약 환자가 대기 중입니다. arr는 진료를 위해 대기 중인 환자들의 진료 부위 수를 나타냅니다.
병원에는 n개만큼의 진료소가 있고, 1개의 진료 부위를 진료하는 데 1분이 소요된다고 가정합니다.
이때 예약 환자가 모두 진료받는 데 걸리는 시간 분을 구하는 함수, solution을 완성해주세요.

예를 들어, arr [1, 1, 1, 2, 2, 1, 1]가 있고, n이 3일 때, 모두 진료받는 시간은 6분입니다.

0분에 진료소 [-, -, -] 전부 비어있고, arr는 [1, 1, 1, 2, 2, 1, 1]입니다.
1분에 진료소 [1, 1, 1] 진료 부위가 남고, arr는 [2, 2, 1, 1]입니다.
2분에 진료소 [-, -, -] 전부 비어있고, arr는 [2, 2, 1, 1]입니다.
3분에 진료소 [2, 2, 1] 진료 부위가 남고, arr는 [1]입니다.
4분에 진료소 [1, 1, -] 3 진료소가 비어있고, arr는 [1]입니다.
5분에 진료소 [-, -, 1] 진료 부위가 남고, arr는 [] 입니다.
6분에 모든 진료가 끝납니다.

[제한 사항]

arr의 순서대로 진료받습니다.
진료소 입장하는 데 1분이 소요됩니다.
[입력 형식]

진료 부위를 나타내는 arr는 길이가 1 이상 1,000 이하의 배열입니다.
진료 부위는 1 이상 10 이하의 정수입니다.
진료소의 수 n은 1 이상 10 이하의 정수입니다.
[출력 형식]

모든 환자가 진료받는 시간 분을 int 형식으로 구합니다.








*/